#!/usr/bin/env bash
clear 
green=`tput setaf 46`     
RED=`tput setaf 196`        
reset=`tput sgr0`

mkdir backups &> /dev/null
cd backups

banner() {
echo "${green}              __               
   |  | |__| /  \  /\   |\/| | 
   |/\| |  | \__/ /~~\  |  | | 
${reset}"
}

host() { 
		if cat /etc/hostname &> hostname ; then
			echo -n "${green} + ${reset}" && echo "Fake host name module has been run successfully.${reset}" && sleep 1
		else
			echo -n "${RED} - ${reset}" && echo "Failed to run fake hostname module.${reset}" && exit 1
		fi
		cat /etc/hosts &> hosts
		hexchars="ABCDEF789654321"
		end=$( for i in {1..6} ; do echo -n ${hexchars:$(( $RANDOM % 16 )):1} ; done | sed -e 's/\(..\)/I\1/g' )
		start=$( for i in {1..4} ; do echo -n ${hexchars:$(( $RANDOM % 16 )):1} ; done | sed -e 's/\(..\)/I\1/g' )
		one=$( for i in {1..2} ; do echo -n ${hexchars:$(( $RANDOM % 16 )):1} ; done | sed -e 's/\(..\)/ \1/g' )
		fakeid=($one$start$end)  
		echo "127.0.0.1       localhost $fakeid
::1             localhost ip6-localhost ip6-loopback
fe00::0         ip6-localnet
ff00::0         ip6-mcastprefix
ff02::1         ip6-allnodes
ff02::2         ip6-allrouters" > /etc/hosts 
echo "$fakeid" > /etc/hostname 

}

dns() {
		if cat /etc/resolv.conf &> resolv.conf ; then
			echo -n "${green} + ${reset}" && echo "The DNS module has been run successfully.${reset}" && sleep 1
		else
			echo -n "${RED} - ${reset}" && echo "Failed to run DNS module.${reset}" && exit 1
		fi  
		echo "# Generated by Whoami
nameserver 84.200.69.80
nameserver 84.200.70.40
nameserver 91.239.100.100
# NOTE: the libc resolver may not support more than 3 nameserver.
# The nameserver listed below may not be recognized.
nameserver 89.233.43.71
nameserver 192.168.1.1" > /etc/resolv.conf
}

mac_channger() { 

		echo -n "${green} * Network interface âž¤ ${reset}" && read macc
		echo "ifconfig $macc down" > mac.sh
		echo -n "ifconfig $macc hw ether " >> mac.sh  && ifconfig eth0 2>/dev/null | grep ether | cut -b 15-31 >> mac.sh 
		echo "ifconfig $macc up" >> mac.sh 
		n=0
		until [ $n -ge 10 ]
		do 
		command &&
		RAND_MAC() {

		gen() {
		NUM="$(tr -dc '0-9a-f' </dev/urandom | head -c 2)"
		echo -n "$NUM:"
		}

		for c in {1..6}; do

		   if [ "$c" -lt "6" ]; then
		      gen
		   else
		      gen | tr -d ':'
		   fi

		done
		} 
		n=$[$n+1]
		out=$(RAND_MAC) 
		echo $out
		cd backups
		ifconfig $macc down  
		ifconfig $macc hw ether $out
		ifconfig $macc up 
		done &> /dev/null
		if cat /sys/class/net/$macc/address &> /dev/null ; then
			echo -n "${green} + ${reset}" && echo "The fake MAC module has been run successfully.${reset}" && sleep 1
		else
			echo -n "${RED} - ${reset}" && echo "Failed to run fake MAC address module.${reset}" && exit 1
		fi
}

ip() {		

		    if tor -h &> /dev/null ; then
				sleep 1
			else echo -n "${RED} - Tor is not installed on your system${reset}" && echo "${green} installation started.${reset}" 
				if apt-get install tor -y &> /dev/null ; then
					sleep 1
				else echo "${RED} - Tor installation failed update the system's sources.list file and try again.${reset}" && exit 1
				fi
			fi

			if cd .. && mkdir -p /usr/share/whoami/data &> /dev/null && mkdir -p /usr/share/whoami/backups &> /dev/null && install -Dm644 data/* /usr/share/whoami/data &> /dev/null && cd backups &> /dev/null; then	
				sleep 1
			else echo "${RED} - Failed to create backup folder.${reset}" && exit 1
			fi
				

readonly config_dir="/usr/share/whoami/data"
readonly backup_dir="/usr/share/whoami/backups"
readonly tor_uid="$(id -u debian-tor)"
readonly trans_port="9040"
readonly dns_port="5353"
readonly virtual_address="10.192.0.0/10"
readonly non_tor="127.0.0.0/8 10.0.0.0/8 172.16.0.0/12 192.168.0.0/16"

die() {
    
    exit 1
}

check_root() {
    if [[ "$(id -u)" -ne 0 ]]; then
        die 
    fi
}

check_settings() {
    declare -a dependencies=('tor' 'curl')

    for package in "${dependencies[@]}"; do
        if ! hash "${package}" 2>/dev/null; then
            die 
        fi
    done

    if [ ! -d "$backup_dir" ]; then
        die 
    fi

    if [ ! -d "$config_dir" ]; then
        die 
    fi

    if [[ ! -f /etc/tor/torrc ]]; then

        if ! cp -vf "$config_dir/torrc" /etc/tor/torrc &> /dev/null; then
            die 
        fi
    else
        
        grep -q -x 'VirtualAddrNetworkIPv4 10.192.0.0/10' /etc/tor/torrc
        local string1=$?

        grep -q -x 'AutomapHostsOnResolve 1' /etc/tor/torrc
        local string2=$?

        grep -q -x 'TransPort 9040 IsolateClientAddr IsolateClientProtocol IsolateDestAddr IsolateDestPort' /etc/tor/torrc
        local string3=$?

        grep -q -x 'SocksPort 9050' /etc/tor/torrc
        local string4=$?

        grep -q -x 'DNSPort 5353' /etc/tor/torrc
        local string5=$?

        if [[ "$string1" -ne 0 ]] ||
           [[ "$string2" -ne 0 ]] ||
           [[ "$string3" -ne 0 ]] ||
           [[ "$string4" -ne 0 ]] ||
           [[ "$string5" -ne 0 ]]; then

            if ! cp -vf /etc/tor/torrc "$backup_dir/torrc.backup" &> /dev/null; then
                die 
            fi

            if ! cp -vf "$config_dir/torrc" /etc/tor/torrc &> /dev/null; then
                die 
            fi
        fi
    fi

    systemctl --system daemon-reload

}

setup_iptables() {
    case "$1" in
        tor_proxy)

            if ! [[ -f /etc/iptables.rules ]]; then
                iptables-save > "$backup_dir/iptables.backup"
            fi

            iptables -F
            iptables -X
            iptables -t nat -F
            iptables -t nat -X

            iptables -t nat -A OUTPUT -d $virtual_address -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j REDIRECT --to-ports $trans_port

            iptables -t nat -A OUTPUT -d 127.0.0.1/32 -p udp -m udp --dport 53 -j REDIRECT --to-ports $dns_port

            iptables -t nat -A OUTPUT -m owner --uid-owner $tor_uid -j RETURN
            iptables -t nat -A OUTPUT -o lo -j RETURN

            for lan in $non_tor; do
                iptables -t nat -A OUTPUT -d $lan -j RETURN
            done

            iptables -t nat -A OUTPUT -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -j REDIRECT --to-ports $trans_port

            iptables -A INPUT -m state --state ESTABLISHED -j ACCEPT
            iptables -A INPUT -i lo -j ACCEPT
            iptables -A INPUT -j DROP

            iptables -A FORWARD -j DROP

            iptables -A OUTPUT -m conntrack --ctstate INVALID -j DROP

            iptables -A OUTPUT -m state --state INVALID -j DROP
            iptables -A OUTPUT -m state --state ESTABLISHED -j ACCEPT

            iptables -A OUTPUT -m owner --uid-owner $tor_uid -p tcp -m tcp --tcp-flags FIN,SYN,RST,ACK SYN -m state --state NEW -j ACCEPT

            iptables -A OUTPUT -d 127.0.0.1/32 -o lo -j ACCEPT

            iptables -A OUTPUT -d 127.0.0.1/32 -p tcp -m tcp --dport $trans_port --tcp-flags FIN,SYN,RST,ACK SYN -j ACCEPT

            iptables -A OUTPUT -j DROP

            iptables -P INPUT DROP
            iptables -P FORWARD DROP
            iptables -P OUTPUT DROP

        ;;

        default)

            iptables -F
            iptables -X
            iptables -t nat -F
            iptables -t nat -X
            iptables -P INPUT ACCEPT
            iptables -P FORWARD ACCEPT
            iptables -P OUTPUT ACCEPT

            if ! [[ -f "${backup_dir}/iptables.backup" ]]; then
                iptables-restore < "${backup_dir}/iptables.backup"

            fi
        ;;
    esac
}

torstart() {
	echo -n "${green} + ${reset}" && echo "Tor's transparent proxy module has been run successfully." && sleep 1
    check_root
    sleep 2
    check_settings

    if systemctl is-active tor.service >/dev/null 2>&1; then
        systemctl stop tor.service
    fi

    if ! cp -vf /etc/resolv.conf "$backup_dir/resolv.conf.backup" &> /dev/null ; then
        die 
    fi

    printf "%s\\n" "nameserver 127.0.0.1" > /etc/resolv.conf
    sleep 1

    sysctl -w net.ipv6.conf.all.disable_ipv6=1 &> /dev/null
    sysctl -w net.ipv6.conf.default.disable_ipv6=1 &> /dev/null

    if systemctl start tor.service 2>/dev/null; then
        sleep 1
    else
        die 
    fi

    setup_iptables tor_proxy

}

torstop() {
    check_root

    sleep 2

    setup_iptables default

    systemctl stop tor.service

    if hash resolvconf 2>/dev/null; then
        resolvconf -u
    else
        cp -vf "$backup_dir/resolv.conf.backup" /etc/resolv.conf &> /dev/null
    fi
    sleep 1

    sysctl -w net.ipv6.conf.all.disable_ipv6=0 &> /dev/null
    sysctl -w net.ipv6.conf.default.disable_ipv6=0 &> /dev/null

    cp -vf "$backup_dir/torrc.backup" /etc/tor/torrc &> /dev/null

}

}

host_stop(){
		if rm -fr /etc/hosts &> /dev/null && rm -fr cat /etc/hostname &> /dev/null && mv hosts /etc/hosts &> /dev/null && mv hostname /etc/hostname &> /dev/null && rm -fr hostname &> /dev/null && rm -fr hosts &> /dev/null ; then
			echo -n "${green} + ${reset}" && echo "Fake hostname module stopped successfully.${reset}" && sleep 1
		else
			echo -n "${RED} - ${reset}" && echo "Failed to stop fake hostname module.${reset}" && exit 1
		fi
		
}
dns_stop(){
		if rm -fr /etc/resolv.conf &> /dev/null && mv resolv.conf /etc/resolv.conf &> /dev/null && rm -fr resolv.conf &> /dev/null ; then
			echo -n "${green} + ${reset}" && echo "DNS module stopped successfully.${reset}" && sleep 1
		else
			echo -n "${RED} - ${reset}" && echo "Failed to stop DNS module.${reset}" && exit 1
		fi
}
mac_channger_stop(){
		if bash mac.sh &> /dev/null && rm -fr mac.sh &> /dev/null ; then
			echo -n "${green} + ${reset}" && echo "The fake MAC module stopped successfully.${reset}" && sleep 1
		else
			echo -n "${RED} - ${reset}" && echo "Failed to stop fake MAC address module.${reset}" && exit 1
		fi
} 
ip_stop(){
		 if ip && torstop &> /dev/null && rm -Rf /usr/share/whoami &> /dev/null && rm -Rf /usr/share/whoami &> /dev/null && rm -Rf /usr/local/bin/whoami &> /dev/null ; then
			echo -n "${green} + ${reset}" && echo "Tor's transparent proxy module stopped successfully.${reset}" && sleep 1
		else
			echo -n "${RED} - ${reset}" && echo "Failed to stop Tor's transparent proxy module.${reset}" && exit 1
		fi

}

usage() { 
	echo " Advanced anonymity tool for Linux
 Usage   : sudo bash whoami [-OPTION]
 Example : sudo bash whoami -h -d -m -i
 Options:

     -h 	Enables fake host name module
     -d	    	The system automatically starts using reliable DNS servers
     -m 	Enables fake MAC address module 
     -i 	Hides rope using Tor's transparent proxy
     -sh  	Turns off the fake host name module
     -sd	Turns off DNS module
     -sm    	Turns off fake MAC address module
     -si 	Turns off Tor's transparent proxy
     -help  	Displays this menu"

}

banner
if [ "$(id -u)" != "0" ]; then
   echo "${RED}This script must be run as root" 1>&2
   exit 1
fi

main() {
    if [[ "$#" -eq 0 ]]; then
	    echo "${RED}Whoami : No setting specified"
		echo "${RED}Try 'whoami -help' for more information."
        exit 1
    fi

    while [[ "$#" -gt 0 ]]; do
        case "$1" in
            -h | --host)
                host
                ;;
            -d | --dns)
                dns
                ;;
	        -m | --mac) 
                mac_channger
				;;
	        -i | --ip)
                ip
                torstart
                ;;
           -sh | --host)
                host_stop
                ;;
		   -sd | --stopdns)
                dns_stop
                ;;
           -sm | --stopmac)
                mac_channger_stop  
                ;;
           -si | --stopip)
                ip_stop
                ;;             
	     -help | --help)
                usage
                exit 0
                ;;
            -- | -* | *)
				echo " "
				echo "${RED}Whoami : Invalid option '$1' "
				echo "${RED}Try 'whoami -help' for more information."
                exit 1
                ;;
        esac
        shift
    done
}

main "$@"
